Signing PDF files
=================

Signing PDF files using pyHanko can be very simple or somewhat complicated,
depending on the specific requirements of your use case.
PyHanko offers support for both visible and invisible signatures, several
baseline PAdES profiles, seed values, and creating signatures using PKCS#11
devices\ [#pkcs11]_.


Some background on PDF signatures
---------------------------------

In order to properly understand the way pyHanko operates, having some background
on the way PDF signatures work is useful.
The goal of this subsection is to provide a bird's eye view, and covers only
the bare minimum. For further details, please refer to the relevant sections
of the ISO 32000 standard(s).

A PDF signature is always contained in a signature *field* in the PDF's
form structure.
Freeware PDF readers that do not have form editing functionality will typically
not allow you to manipulate signature fields directly, but might allow you to
fill existing form fields with a signature, or create a signature together with
its corresponding form field.
Using pyHanko, you can both insert new (empty) signature fields, and fill in
existing ones.

Separate from the signature field containing it, a signature may or may not have
an *appearance* associated with it. Signatures without such an appearance are
referred to as *invisible* signatures.
Invisible signatures have the advantage of being comparatively simpler to
implement and configure, but when a PDF containing an invisible signature
is opened in a reader application without signature support, it may not
be visually obvious that the PDF file even contains a signature at all.

The signature object itself contains some PDF-specific metadata, such as

 * the byte range of the file that it covers;
 * the hash function used to compute the document hash to be signed;
 * a modification policy that indicates the ways in which the file can still
   be modified.

The actual cryptographic signature is embedded as a CMS object.
General CMS objects are defined in
`RFC 5652 <https://tools.ietf.org/html/rfc5652>`_, but only a limited subset
is meaningful in PDF.
When creating a signature, the signer is authenticated using the private key
associated with an X.509 certificate, as issued by most common PKI authorities
nowadays.
The precise way this private key is provisioned is immaterial: it can be read
from a file on disk, or the signature can be generated by a hardware token;
this has no impact on the structure of the signature object in the file.


In a typical signed PDF file with only one signature, the signed byte range
covers the entire document, except for the area containing the actual
CMS data of the signature. However, there are a number of legitimate reasons
why this may *not* be the case:

 * documents containing multiple signatures and/or timestamps;
 * signatures that allow further modification, such as form filling
   or annotation.

Generally speaking, the signer decides what modifications are still
permitted after a signature is made\ [#modpolexceptions]_.

The cryptographically informed reader might ask how it is *at all* possible to
modify a file without invalidating the signature.
After all, hash functions are supposed to prevent exactly this kind of thing.
The answer here lies in the *incremental update* feature of the PDF standard.
The specification allows for updating files by appending data to the end of the
file, keeping the original bytes in place.
These incremental update sections can create and modify existing objects in the
file, while still preserving the original version in some form.
Such changes are typically opaque to the user that views the file.
The byte range attached to the signature ensures that the document hash can
still be computed over the original data, and thus the integrity of the
signature can still be validated.

However, since incremental updates allow the final rendered document to be
modified in essentially arbitrary ways, the onus is on the *validator* to ensure
that all such incremental updates made after a signature was created actually
are "legitimate" changes. What precisely constitutes a "legitimate" change
depends on the signature's modification policy, but is not rigorously defined
in the standard\ [#validationscope]_.
It goes without saying that this has led to various
`exploits <https://pdf-insecurity.org/>`_ where PDF readers could be duped into
allowing illicit modifications to signed PDF files without raising suspicion.
As a consequence of this, some signature validation tools do not even bother
to do any such validation, and simply reject *all* signatures in documents that
have been modified through incremental updates.

See :doc:`validation` for an overview of pyHanko's signature validation
features.


Creating simple signatures
--------------------------


Creating signature fields
-------------------------


Creating signatures with long lifetimes
---------------------------------------


.. rubric:: Footnotes
.. [#pkcs11]
    The PKCS#11 functionality is currently only exposed in the CLI for
    Belgian eID cards, but it should be reasonably easy to write an
    implementation that works for any PKCS#11 device. That being said,
    my experience with general PKCS#11 is limited, and I'm not 100% sure about
    current best practices for generic PKCS#11 clients (key selection,
    key-certificate pairing, ...).
    Discussion and (properly motivated) pull requests are certainly welcome!
.. [#modpolexceptions]
    There are some legitimate modifications that cannot be prohibited by
    any document modification policy, such as the addition of document
    timestamps and updates to the document security store.
.. [#validationscope]
    The author has it on good authority that a rigorous validation specification
    is beyond the scope of the PDF standard itself.

